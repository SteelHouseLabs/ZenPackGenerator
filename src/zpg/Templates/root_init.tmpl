import logging
log = logging.getLogger('zen.${NAME}')

import os
import Globals

from Products.ZenModel.Device import Device
from Products.ZenModel.ZenPack import ZenPack as ZenPackBase
from Products.ZenRelations.RelSchema import ToManyCont, ToOne
from Products.ZenRelations.zPropertyCategory import setZPropertyCategory
from Products.CMFCore.DirectoryView import registerDirectory
from Products.Zuul.interfaces import ICatalogTool
from Products.ZenUtils.Utils import unused

unused(Globals)

skinsDir = os.path.join(os.path.dirname(__file__), 'skins')
if os.path.isdir(skinsDir):
    registerDirectory(skinsDir, globals())

ZENPACK_NAME = '${NAME}'

#if len($classes) > 0
# Modules containing model classes. Used by zenchkschema to validate
# bidirectional integrity of defined relationships.
productNames = (
#for $c in $classes
    '$c',
#end for
    )
#end if

# Define new device relations.
NEW_DEVICE_RELATIONS = (
#for $dr in $NEW_DEVICE_RELATIONS
    $dr
#end for
    )

NEW_COMPONENT_TYPES = (
#for $ct in $NEW_COMPONENT_TYPES
    '$ct',
#end for
    )

# Add new relationships to Device if they don't already exist.
for relname, modname, devrel in NEW_DEVICE_RELATIONS:
    if relname not in (x[0] for x in Device._relations):
        Device._relations += (
            (relname, ToManyCont(ToOne,
                '.'.join(ZENPACK_NAME, modname)), devrel)),
            )

# Useful to avoid making literal string references to module and class names
# throughout the rest of the ZenPack.
MODULE_NAME = {}
CLASS_NAME = {}
for product_name in productNames:
    ZP_NAME = '${NAME}'
    MODULE_NAME[product_name] = '.'.join([ZP_NAME, product_name])
    CLASS_NAME[product_name] = '.'.join([ZP_NAME, product_name, product_name])


_PACK_Z_PROPS = [
#for $zprop in $ZPROPERTIES
                $zprop
#end for
                ]

#if len($ZPROPERTIES) > 0 and $ZPROPERTY_CATEGORY
for name, default_value, type_ in _PACK_Z_PROPS:
    setzPropertyCategory(name, '$ZPROPERTY_CATEGORY')
#end if


class ZenPack(ZenPackBase):

    packZProperties = _PACK_Z_PROPS

    def install(self,app):
        super(ZenPack, self).install(app)
        log.info('Adding ${NAME} relationships to existing devices')

        self._buildDeviceRelations()

    def remove(self, app, leaveObjects=False):
        if not leaveObjects:
            log.info('Removing ${NAME} components')
            cat = ICatalogTool(app.zport.dmd)

            # Search the catalog for components of this zenpacks type.
            for brain in cat.search(types=NEW_COMPONENT_TYPES):
                component = brain.getObject()
                component.getPrimaryParent()._delObject(component.id)

            # Remove our Device relations additions.
            Device._relations = tuple(
                [x for x in Device._relations \
                    if x[0] not in NEW_DEVICE_RELATIONS])

            log.info('Removing ${NAME} relationships from existing devices')
            self._buildDeviceRelations()
 
        super(ZenPack, self).remove(app, leaveObjects=leaveObjects)

    def _buildDeviceRelations(self):
        for d in self.dmd.Devices.getSubDevicesGen():
            d.buildRelations()
